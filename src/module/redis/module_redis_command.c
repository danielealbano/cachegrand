/**
 * Copyright (C) 2018-2022 Daniele Salvatore Albano
 * All rights reserved.
 *
 * This software may be modified and distributed under the terms
 * of the BSD license.  See the LICENSE file for details.
 **/

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <string.h>
#include <strings.h>
#include <arpa/inet.h>
#include <assert.h>

#include "misc.h"
#include "exttypes.h"
#include "log/log.h"
#include "spinlock.h"
#include "clock.h"
#include "config.h"
#include "data_structures/small_circular_queue/small_circular_queue.h"
#include "data_structures/double_linked_list/double_linked_list.h"
#include "data_structures/hashtable/mcmp/hashtable.h"
#include "data_structures/queue_mpmc/queue_mpmc.h"
#include "slab_allocator.h"
#include "protocol/redis/protocol_redis.h"
#include "protocol/redis/protocol_redis_reader.h"
#include "protocol/redis/protocol_redis_writer.h"
#include "module/module.h"
#include "network/io/network_io_common.h"
#include "network/channel/network_channel.h"
#include "network/network.h"
#include "storage/io/storage_io_common.h"
#include "storage/channel/storage_channel.h"
#include "storage/db/storage_db.h"
#include "module/redis/module_redis.h"
#include "module_redis_connection.h"

#include "module_redis_command.h"

#define TAG "module_redis_command"

// There is no easy way to know the amount of the padding that the compiler can introduce in a struct but the
// optimization is normally applied in the same way to the same kind of structs.
// The command context structs generated by the scaffolding generator hold a boolean field (has_token) at the beginning
// if the argument associated with that specific field has a token.
// Because of the boolean field at the beginning, normally the compiler will introduce a 7 byte padding on the x86-64
// arch.
// There isn't an easy way to properly detect the padding and definitely having a massive set of ifdefs is not ideal so
// below there is a fake struct used by the code to determine the amount of padding, operation which is optimized by the
// compiler and costs 0
typedef struct module_redis_command_context_has_token_padding_detection
    module_redis_command_context_has_token_padding_detection_t;
struct module_redis_command_context_has_token_padding_detection {
    bool has_token;
    void *pointer;
};

// The logic below is simple, the code gets the offset of pointer which will be the extra offset to be taken into
// account, it refers to the beginning of the command context address for the member. The has_token offset is assumed to
// be always be zero (validated by a compile-time assert)
COMPILE_TIME_ASSERT(offsetof(module_redis_command_context_has_token_padding_detection_t, has_token)==0);
size_t field_has_token_extra_padding = offsetof(module_redis_command_context_has_token_padding_detection_t, pointer);

bool module_redis_command_is_key_too_long(
        network_channel_t *channel,
        size_t key_length) {
    if (unlikely(key_length > channel->module_config->redis->max_key_length)) {
        return true;
    }

    return false;
}

void build_token_argument_map(
        module_redis_command_argument_t *arguments,
        uint16_t arguments_count,
        module_redis_command_parser_context_token_map_entry_t token_map[],
        uint16_t *token_count) {
    for(uint16_t index = 0; index < arguments_count; index++) {
        module_redis_command_argument_t *argument = &arguments[index];
        if (argument->token != NULL) {
            if (token_map != NULL) {
                module_redis_command_parser_context_token_map_entry_t *token_map_entry = &token_map[*token_count];
                token_map_entry->token = argument->token;
                token_map_entry->argument = argument;
                if (argument->parent_argument &&
                    argument->parent_argument->type == MODULE_REDIS_COMMAND_ARGUMENT_TYPE_ONEOF) {
                    for(
                            uint16_t parent_oneof_token_index = 0;
                            parent_oneof_token_index < argument->parent_argument->sub_arguments_count;
                            parent_oneof_token_index++) {
                        char *one_of_token = argument->parent_argument->sub_arguments[parent_oneof_token_index].token;
                        if (one_of_token && one_of_token != argument->token) {
                            assert(token_map_entry->one_of_token_count <=
                                sizeof(token_map_entry->one_of_tokens) / sizeof(char*));
                            token_map_entry->one_of_tokens[token_map_entry->one_of_token_count] = one_of_token;
                            token_map_entry->one_of_token_count++;
                        }
                    }
                }

            }

            (*token_count)++;
        }

        if (argument->has_sub_arguments) {
            build_token_argument_map(
                    argument->sub_arguments,
                    argument->sub_arguments_count,
                    token_map,
                    token_count);
        }
    }
}

bool module_redis_command_process_begin(
        module_redis_connection_context_t *connection_context) {
    module_redis_command_parser_context_t *command_parser_context = &connection_context->command.parser_context;

    if (connection_context->command.info->context_size > 0) {
        if ((connection_context->command.context = slab_allocator_mem_alloc_zero(
                connection_context->command.info->context_size)) == NULL) {
            LOG_D(TAG, "Unable to allocate the command context, terminating connection");
            return false;
        }
    }

    // The parser for the arguments works in pretty straightforward way:
    // - it expects all the positional non-optional arguments
    // - it then expects the positional optional arguments
    // - stop searching for the positional optional arguments once it finds the first token
    //

    // Builds the token map
    uint16_t token_count = 0;
    module_redis_command_parser_context_token_map_entry_t *token_map = NULL;

    build_token_argument_map(
            connection_context->command.info->arguments,
            connection_context->command.info->arguments_count,
            NULL,
            &token_count);

    if (token_count > 0) {
        token_map = slab_allocator_mem_alloc_zero(
                sizeof(module_redis_command_parser_context_token_map_entry_t) * token_count);
        if (token_map == NULL) {
            return false;
        }

        token_count = 0;
        build_token_argument_map(
                connection_context->command.info->arguments,
                connection_context->command.info->arguments_count,
                token_map,
                &token_count);
    }

    command_parser_context->token_count = token_count;
    command_parser_context->token_map = token_map;

    // Figures out if there is a positional argument that has to be handled
    if (connection_context->command.info->arguments_count > 0 &&
            connection_context->command.info->arguments[0].is_positional) {
        module_redis_command_argument_t *expected_argument = &connection_context->command.info->arguments[0];
        command_parser_context->current_argument.expected_argument = expected_argument;
        command_parser_context->current_argument.block_argument_index = 0;
    } else {
        command_parser_context->current_argument.expected_argument = NULL;
    }

    return true;
}

void *module_redis_command_get_base_context_from_argument(
        module_redis_command_argument_t *argument,
        module_redis_command_argument_t *stop_at_parent_argument,
        module_redis_command_context_t *command_context,
        bool *stopped_at_list,
        uint16_t *stopped_at_list_count,
        module_redis_command_argument_t **stopped_at_list_argument,
        module_redis_command_argument_t **stopped_at_list_resume_from_argument) {
    uintptr_t base_addr = (uintptr_t)command_context;
    int arguments_queue_count = 0, arguments_queue_index;
    module_redis_command_argument_t
        *arguments_queue[4],
        *arguments_resume_from_queue[ARRAY_SIZE(arguments_queue)],
        *previous_argument = NULL;

    // Uses a for to let gcc unroll the loop easily and have only 1 branch based on the parent_argument check but a
    // queue with just 4 slots might not be enough for all the cases and commands so there is an assert right after
    // to ensure the loop ended because it found the expected root or not
    for(
            ;
            // should argument != null if stop_at_parent_argument == null and argument->parent != stop_at_parent_argument if not
            argument != stop_at_parent_argument && arguments_queue_count < ARRAY_SIZE(arguments_queue);
            argument = argument->parent_argument) {
        fprintf(stdout, "%d. %s\n", arguments_queue_count, argument->name); fflush(stderr);
        arguments_queue[arguments_queue_count] = argument;
        arguments_resume_from_queue[arguments_queue_count] = previous_argument;
        previous_argument = argument;
        arguments_queue_count++;
    }

    assert(argument == stop_at_parent_argument);

    for(
            arguments_queue_index = arguments_queue_count - 1;
            arguments_queue_index >= 0;
            arguments_queue_index--) {
        argument = arguments_queue[arguments_queue_index];

        base_addr = base_addr + argument->argument_context_member_offset;

        // If argument is a token, the first element in the context is the boolean value
        if (argument->token != NULL) {
            base_addr += field_has_token_extra_padding;
        }

        // If it's a list we need to stop and return the pointer to the list because the right index has to be
        // identified before the member of the context within the list can be fetched.
        if (argument->has_multiple_occurrences) {
            *stopped_at_list = true;
            *stopped_at_list_count = *(int *)(base_addr + sizeof(void *));
            *stopped_at_list_argument = argument;
//            *stopped_at_list_resume_from_argument = arguments_resume_from_queue[arguments_queue_index];
            *stopped_at_list_resume_from_argument = arguments_queue[arguments_queue_index];
        }

        if (*stopped_at_list) {
            break;
        }
    }

    return (void*)base_addr;
}

void *module_redis_command_context_base_addr_skip_has_token(
        module_redis_command_argument_t *argument,
        void *base_addr) {

    if (argument->token != NULL) {
        base_addr += field_has_token_extra_padding;
    }

    return base_addr;
}

int module_redis_command_context_list_get_count(
        module_redis_command_argument_t *argument,
        void *base_addr) {
    base_addr = module_redis_command_context_base_addr_skip_has_token(argument, base_addr);

    return *(int *)(base_addr + sizeof(void *));
}

void module_redis_command_context_list_set_count(
        module_redis_command_argument_t *argument,
        void *base_addr,
        int count) {
    base_addr = module_redis_command_context_base_addr_skip_has_token(argument, base_addr);

    *(int *)(base_addr + sizeof(void *)) = count;
}

void module_redis_command_context_list_set_list(
        module_redis_command_argument_t *argument,
        void *base_addr,
        void *list) {
    base_addr = module_redis_command_context_base_addr_skip_has_token(argument, base_addr);

    void **list_ptr = (void*)base_addr;
    *list_ptr = list;
}

void *module_redis_command_context_list_get_list(
        module_redis_command_argument_t *argument,
        void *base_addr) {
    base_addr = module_redis_command_context_base_addr_skip_has_token(argument, base_addr);

    void **list_ptr = (void*)base_addr;
    base_addr = *list_ptr;

    return base_addr;
}

void *module_redis_command_context_list_get_entry(
        module_redis_command_argument_t *argument,
        void *base_addr,
        uint16_t index) {
    void *list = module_redis_command_context_list_get_list(argument, base_addr);
    void *list_entry = list + (index * argument->argument_context_member_size);

    return list_entry;
}

void *module_redis_command_context_list_expand_and_get_new_entry(
        module_redis_command_argument_t *argument,
        void *base_addr) {
    void *list, *new_list_entry;
    base_addr = module_redis_command_context_base_addr_skip_has_token(argument, base_addr);

    int list_count = module_redis_command_context_list_get_count(argument, base_addr);
    int list_count_new = list_count + 1;

    // If the list_count is zero it's not necessary to get the current pointer
    if (list_count == 0) {
        list = slab_allocator_mem_alloc_zero(list_count_new * argument->argument_context_member_size);
    } else {
        list = module_redis_command_context_list_get_list(argument, base_addr);
        list = slab_allocator_mem_realloc(
                list,
                list_count * argument->argument_context_member_size,
                list_count_new * argument->argument_context_member_size,
                true);

        if (!list) {
            return NULL;
        }
    }

    module_redis_command_context_list_set_list(argument, base_addr, list);
    module_redis_command_context_list_set_count(argument, base_addr, list_count_new);

    // Calculate the offset of the new entry and return it
    new_list_entry = list + ((list_count_new - 1) * argument->argument_context_member_size);
    return new_list_entry;
}

void module_redis_command_context_has_token_set(
        module_redis_command_argument_t *argument,
        void *base_addr,
        bool has_token) {
    *(bool *)base_addr = has_token;
}

bool module_redis_command_context_has_token_get(
        module_redis_command_argument_t *argument,
        void *base_addr) {
    return *(bool *)base_addr;
}

void module_redis_command_context_value_set(
        module_redis_command_argument_t *argument,
        void *base_addr,
        void *new_value_addr,
        size_t new_value_length) {
    base_addr = module_redis_command_context_base_addr_skip_has_token(argument, base_addr);
    memcpy(base_addr, new_value_addr, new_value_length);
}

void *module_redis_command_context_value_get(
        module_redis_command_argument_t *argument,
        void *base_addr) {
    base_addr = module_redis_command_context_base_addr_skip_has_token(argument, base_addr);
    return base_addr;
}

void *module_redis_command_context_get_argument_member_context_addr(
        module_redis_command_argument_t *argument,
        bool is_in_block,
        int block_argument_index,
        void *context) {
    bool stopped_at_list = false;
    uint16_t stopped_at_list_count = 0;
    void *argument_member_context_addr;
    module_redis_command_argument_t *stopped_at_list_argument, *stopped_at_list_resume_from_argument;

    argument_member_context_addr = module_redis_command_get_base_context_from_argument(
            argument,
            NULL,
            context,
            &stopped_at_list,
            &stopped_at_list_count,
            &stopped_at_list_argument,
            &stopped_at_list_resume_from_argument);
    if (stopped_at_list) {
        // If the argument processing stopped at a list it means that:
        // - if the parser is not parsing a block it can always resize
        // - if the parser is parsing a block it can resize only if it's the first argument of the block (the index is
        //   set back to zero when the argument block is fully parsed)
        // - if the parser is parsing a block and it's not the first argument, it must only retrieve the last entry of
        //   the list without expanding it
        if (is_in_block == false || block_argument_index == 0) {
            argument_member_context_addr = module_redis_command_context_list_expand_and_get_new_entry(
                    stopped_at_list_argument,
                    argument_member_context_addr);
        } else if (block_argument_index > 0) {
            argument_member_context_addr = module_redis_command_context_list_get_entry(
                    stopped_at_list_argument,
                    argument_member_context_addr,
                    stopped_at_list_count - 1);
        }

        // If the resume from argument is not null it means that the list just found is a block and therefore it's
        // necessary to keep digging
        if (stopped_at_list_resume_from_argument != NULL) {
            // Search again but this time as parent use the element right before the one on which we stopped
            module_redis_command_argument_t *stop_at_parent_argument = stopped_at_list_resume_from_argument;
            stopped_at_list = false;
            stopped_at_list_resume_from_argument = NULL;
            argument_member_context_addr = module_redis_command_get_base_context_from_argument(
                    argument,
                    stop_at_parent_argument,
                    argument_member_context_addr,
                    &stopped_at_list,
                    &stopped_at_list_count,
                    &stopped_at_list_argument,
                    &stopped_at_list_resume_from_argument);

            // Nested lists aren't allowed!
            assert(!stopped_at_list);
        }
    }

    return argument_member_context_addr;
}

bool module_redis_command_ensure_argument_key_pattern_allowed_length(
        module_redis_connection_context_t *connection_context,
        module_redis_command_argument_t *argument,
        size_t argument_length) {
    // Checks if the key / pattern length is allowed before doing anything else
    if (
            argument->type == MODULE_REDIS_COMMAND_ARGUMENT_TYPE_KEY ||
            argument->type == MODULE_REDIS_COMMAND_ARGUMENT_TYPE_PATTERN) {
        if (module_redis_command_is_key_too_long(
                connection_context->network_channel,
                argument_length)) {
            module_redis_connection_error_message_printf_noncritical(
                    connection_context,
                    "ERR The %s length has exceeded the allowed size of <%u>",
                    argument->type == MODULE_REDIS_COMMAND_ARGUMENT_TYPE_KEY ? "key" : "pattern",
                    connection_context->network_channel->module_config->redis->max_key_length);
            return false;
        }
    }

    return true;
}

bool module_redis_command_process_argument_begin(
        module_redis_connection_context_t *connection_context,
        uint32_t argument_index,
        uint32_t argument_length) {
    bool is_in_block = false;
    module_redis_command_argument_t *expected_argument;
    module_redis_command_parser_context_t *command_parser_context = &connection_context->command.parser_context;

    expected_argument = command_parser_context->current_argument.expected_argument;

    // If there isn't an expected argument to handle there is nothing that can be done in advance, the only arguments
    // which will be allowed are the ones with tokens, they can't be streamed
    if (expected_argument == NULL) {
        command_parser_context->current_argument.require_stream = false;
        return true;
    }

#if DEBUG == 1
    // Ensure that required arguments don't have tokens as they are positional
    if (expected_argument->is_optional == false) {
        assert(expected_argument->token == NULL);
    }
#endif

    if (expected_argument->type == MODULE_REDIS_COMMAND_ARGUMENT_TYPE_BLOCK) {
        is_in_block = true;
        expected_argument = &expected_argument->sub_arguments[
                command_parser_context->current_argument.block_argument_index];
#if DEBUG == 1
        // Ensure that required arguments don't have tokens as they are positional
        if (expected_argument->is_optional == false) {
            assert(expected_argument->token == NULL);
        }
#endif
    }

    if (!module_redis_command_ensure_argument_key_pattern_allowed_length(
            connection_context,
            expected_argument,
            argument_length)) {
        return false;
    }

    if (expected_argument->type == MODULE_REDIS_COMMAND_ARGUMENT_TYPE_LONG_STRING) {
        command_parser_context->current_argument.member_context_addr =
                module_redis_command_context_get_argument_member_context_addr(
                        expected_argument,
                        is_in_block,
                        command_parser_context->current_argument.block_argument_index,
                        connection_context->command.context);

        module_redis_long_string_t *string = command_parser_context->current_argument.member_context_addr;
        string->chunk_sequence = storage_db_chunk_sequence_allocate(
                connection_context->db,
                argument_length);

        if (!string->chunk_sequence) {
            LOG_E(TAG, "Failed to allocate chunks for the incoming data");
            return false;
        }

        command_parser_context->current_argument.require_stream = true;
    } else {
        command_parser_context->current_argument.require_stream = false;
    }

    return true;
}

bool module_redis_command_process_argument_require_stream(
        module_redis_connection_context_t *connection_context,
        uint32_t argument_index) {
    module_redis_command_parser_context_t *command_parser_context = &connection_context->command.parser_context;

    return command_parser_context->current_argument.require_stream;
}

bool module_redis_command_process_argument_stream_data(
        module_redis_connection_context_t *connection_context,
        uint32_t argument_index,
        char *chunk_data,
        size_t chunk_length) {
    bool is_in_block = false;
    module_redis_long_string_t *string;
    storage_db_chunk_sequence_t *chunk_sequence;
    module_redis_command_parser_context_t *command_parser_context = &connection_context->command.parser_context;
    module_redis_command_argument_t *expected_argument = command_parser_context->current_argument.expected_argument;
    void *argument_member_context_addr = command_parser_context->current_argument.member_context_addr;

    // Streaming is only allowed for positional arguments that are strings, tokens will never have to handle strings
    assert(expected_argument != NULL);

    if (expected_argument->type == MODULE_REDIS_COMMAND_ARGUMENT_TYPE_BLOCK) {
        is_in_block = true;
        expected_argument = &expected_argument->sub_arguments[
                command_parser_context->current_argument.block_argument_index];
#if DEBUG == 1
        // Ensure that required arguments don't have tokens as they are positional
        if (expected_argument->is_optional == false) {
            assert(expected_argument->token == NULL);
        }
#endif
    }

    assert(expected_argument->type == MODULE_REDIS_COMMAND_ARGUMENT_TYPE_LONG_STRING);

    string = argument_member_context_addr;
    chunk_sequence = string->chunk_sequence;

    size_t written_data = 0;
    do {
        storage_db_chunk_info_t *chunk_info = storage_db_chunk_sequence_get(
                chunk_sequence,
                string->current_chunk.index);

        size_t chunk_available_size = chunk_info->chunk_length - string->current_chunk.offset;
        size_t chunk_data_to_write_length =
                chunk_length > chunk_available_size ? chunk_available_size : chunk_length;

        bool res = storage_db_chunk_write(
                connection_context->db,
                chunk_info,
                string->current_chunk.offset,
                chunk_data,
                chunk_data_to_write_length);

        if (!res) {
            LOG_E(
                    TAG,
                    "Unable to write value chunk <%u> long <%u> bytes",
                    string->current_chunk.index,
                    chunk_info->chunk_length);
            return false;
        }

        written_data += chunk_data_to_write_length;
        string->current_chunk.offset += (off_t)chunk_data_to_write_length;

        if (string->current_chunk.offset == chunk_info->chunk_length) {
            string->current_chunk.index++;
        }
    } while(written_data < chunk_length);

    return true;
}

bool module_redis_command_process_argument_stream_end(
        module_redis_connection_context_t *connection_context) {
    module_redis_command_parser_context_t *command_parser_context = &connection_context->command.parser_context;

    return true;
}

bool module_redis_command_process_argument_full(
        module_redis_connection_context_t *connection_context,
        uint32_t argument_index,
        char *chunk_data,
        size_t chunk_length) {
    bool check_tokens = false, is_in_block = false;
    module_redis_command_argument_t *guessed_argument = NULL;
    module_redis_command_parser_context_t *command_parser_context = &connection_context->command.parser_context;
    module_redis_command_argument_t *expected_argument = command_parser_context->current_argument.expected_argument;

    // The guessing argument logic is pretty straight forward:
    // - if the expected positional argument is not NULL and it's marked as required, that's what we are looking for, no
    //   need to further guess
    // - if the expected positional argument is not NULL and it's marked as optional, it's necessary to check if the
    //   received argument is a token or not

    if (expected_argument != NULL) {
        if (expected_argument->type == MODULE_REDIS_COMMAND_ARGUMENT_TYPE_BLOCK) {
            is_in_block = true;
            expected_argument = &expected_argument->sub_arguments[
                    command_parser_context->current_argument.block_argument_index];
        }

        if (expected_argument->is_optional == false) {
            // If it's required the guessing is easy
            guessed_argument = expected_argument;
        } else {
            check_tokens = true;
        }
    } else {
        check_tokens = true;
    }

    if (check_tokens) {
        // TODO
        assert(false);
    }

    // If guessed argument is null it means it wasn't possible to find one, report the error and return false
    if (guessed_argument == NULL) {
        module_redis_connection_error_message_printf_noncritical(
                connection_context,
                "ERR the command '%s' doesn't support the parameter '%*s'",
                connection_context->command.info->string,
                MIN((int)chunk_length, 128),
                chunk_data);
        return true;
    }

    if (!module_redis_command_ensure_argument_key_pattern_allowed_length(
            connection_context,
            guessed_argument,
            chunk_length)) {
        return false;
    }

    command_parser_context->current_argument.member_context_addr =
            module_redis_command_context_get_argument_member_context_addr(
                    guessed_argument,
                    is_in_block,
                    command_parser_context->current_argument.block_argument_index,
                    connection_context->command.context);

    // Handle arguments which require memory allocation
    if (
            guessed_argument->type == MODULE_REDIS_COMMAND_ARGUMENT_TYPE_KEY ||
            guessed_argument->type == MODULE_REDIS_COMMAND_ARGUMENT_TYPE_PATTERN) {
        char *key_or_pattern = slab_allocator_mem_alloc(chunk_length);

        if (!key_or_pattern) {
            LOG_E(TAG, "Failed to allocate memory for the incoming data");
            return false;
        }

        strncpy(key_or_pattern, chunk_data, chunk_length);

        if (guessed_argument->type == MODULE_REDIS_COMMAND_ARGUMENT_TYPE_KEY) {
            module_redis_key_t *key = command_parser_context->current_argument.member_context_addr;
            key->key = key_or_pattern;
            key->length = chunk_length;
        } else {
            module_redis_pattern_t *pattern = command_parser_context->current_argument.member_context_addr;
            pattern->pattern = key_or_pattern;
            pattern->length = chunk_length;
        }
    } else {
        // TODO
        assert(false);
    }

    return true;
}

bool module_redis_command_process_argument_end(
        module_redis_connection_context_t *connection_context,
        uint32_t argument_index) {
    module_redis_command_parser_context_t *command_parser_context = &connection_context->command.parser_context;
    module_redis_command_argument_t *expected_argument = command_parser_context->current_argument.expected_argument;

    if (!expected_argument) {
        return true;
    }

    if (expected_argument->type == MODULE_REDIS_COMMAND_ARGUMENT_TYPE_BLOCK) {
        // TODO: is it necessary to handle cases where a positional argument contains a block which contains tokens?
        //       Possible, but is it necessary? Need to investigate redis commands, from a quick check doesn't seem the
        //       case
        command_parser_context->current_argument.block_argument_index++;

        if (command_parser_context->current_argument.block_argument_index <
                expected_argument->sub_arguments_count) {
            return true;
        }

        // If it gets here it means that all the arguments in the block have been processed so is_in_block can be
        // marked as false
        command_parser_context->current_argument.block_argument_index = 0;
    }

    // Check if the there is an expected positional argument set, if it does no tokens have been found yet and there
    // might be further positional arguments to be processed
    // Also, if the current argument (expected positional argument is automatically the current argument if it's not
    // null at this point) is positional and is multi, will never move to the next argument unless it's a token so do
    // nothing in this case.
    if (!expected_argument->is_positional) {
        expected_argument = NULL;
    } else if(!expected_argument->has_multiple_occurrences) {
        expected_argument = NULL;

        // Check if there are more arguments
        if (command_parser_context->positional_arguments_parsed_count <
        connection_context->command.info->arguments_count) {
            command_parser_context->positional_arguments_parsed_count++;
            expected_argument = &connection_context->command.info->arguments[
                    command_parser_context->positional_arguments_parsed_count];

            // If the argument after the current is not positional they have all been processed and there are only
            // tokens to process so set it to null
            if (!expected_argument->is_positional) {
                expected_argument = NULL;
            }
        }
    }

    command_parser_context->current_argument.expected_argument = expected_argument;

    return true;
}

bool module_redis_command_process_end(
        module_redis_connection_context_t *connection_context) {
    module_redis_command_parser_context_t *command_parser_context = &connection_context->command.parser_context;
    module_redis_command_argument_t *expected_argument = command_parser_context->current_argument.expected_argument;

    if (
            expected_argument &&
            expected_argument->type == MODULE_REDIS_COMMAND_ARGUMENT_TYPE_BLOCK &&
            command_parser_context->current_argument.block_argument_index > 0) {
        return module_redis_connection_error_message_printf_noncritical(
                connection_context,
                "ERR wrong number of arguments for %s",
                connection_context->command.info->string);
    }

    return connection_context->command.info->command_end_funcptr(
            connection_context);
}

bool module_redis_command_process_try_free(
        module_redis_connection_context_t *connection_context) {
    if (connection_context->command.parser_context.token_map) {
        slab_allocator_mem_free(connection_context->command.parser_context.token_map);
        connection_context->command.parser_context.token_map = 0;
    }

    if (connection_context->command.info == NULL || connection_context->command.context == NULL) {
        return true;
    }

#if DEBUG == 1
    module_redis_command_dump_arguments(
            connection_context->db,
            connection_context->command.info->arguments,
            connection_context->command.info->arguments_count,
            (uintptr_t)connection_context->command.context,
            0);
#endif

    connection_context->command.info->command_free_funcptr(
            connection_context);

    connection_context->command.context = NULL;

    return true;
}

bool module_redis_command_acquire_slice_and_write_blob_start(
        network_channel_t *network_channel,
        size_t slice_length,
        size_t value_length,
        network_channel_buffer_data_t **send_buffer,
        network_channel_buffer_data_t **send_buffer_start,
        network_channel_buffer_data_t **send_buffer_end) {
    *send_buffer = *send_buffer_start = network_send_buffer_acquire_slice(
            network_channel,
            slice_length);
    if (*send_buffer_start == NULL) {
        LOG_E(TAG, "Unable to acquire send buffer slice!");
        return false;
    }

    *send_buffer_end = *send_buffer_start + slice_length;

    *send_buffer_start = protocol_redis_writer_write_argument_blob_start(
            *send_buffer_start,
            slice_length,
            false,
            (int)value_length);

    if (*send_buffer_start == NULL) {
        network_send_buffer_release_slice(
                network_channel,
                0);
        LOG_E(TAG, "buffer length incorrectly calculated, not enough space!");
        return false;
    }

    return true;
}

bool module_redis_command_stream_entry_with_one_chunk(
        network_channel_t *network_channel,
        storage_db_t *db,
        storage_db_entry_index_t *entry_index) {
    bool res = false, result_res = false;
    network_channel_buffer_data_t *send_buffer = NULL, *send_buffer_start = NULL, *send_buffer_end = NULL;
    storage_db_chunk_info_t *chunk_info;

    if (!module_redis_command_acquire_slice_and_write_blob_start(
            network_channel,
            MIN(entry_index->value->size + 32, STORAGE_DB_CHUNK_MAX_SIZE),
            entry_index->value->size,
            &send_buffer,
            &send_buffer_start,
            &send_buffer_end)) {
        return false;
    }

    chunk_info = storage_db_chunk_sequence_get(
            entry_index->value,
            0);

    res = storage_db_chunk_read(
            db,
            chunk_info,
            send_buffer_start);

    if (!res) {
        LOG_E(
                TAG,
                "[REDIS][GET] Critical error, unable to read chunk <%u> long <%u> bytes",
                0,
                chunk_info->chunk_length);
        return false;
    }

    send_buffer_start += chunk_info->chunk_length;

    send_buffer_start = protocol_redis_writer_write_argument_blob_end(
            send_buffer_start,
            send_buffer_end - send_buffer_start);

    if (send_buffer_start == NULL) {
        LOG_E(TAG, "buffer length incorrectly calculated, not enough space!");
        goto end;
    }

    network_send_buffer_release_slice(
            network_channel,
            send_buffer_start - send_buffer);
    send_buffer = NULL;

    result_res = true;

    end:

    if (send_buffer != NULL && !result_res) {
        network_send_buffer_release_slice(
                network_channel,
                0);
    }

    return result_res;
}

bool module_redis_command_stream_entry_with_multiple_chunks(
        network_channel_t *network_channel,
        storage_db_t *db,
        storage_db_entry_index_t *entry_index) {
    bool res;
    network_channel_buffer_data_t *send_buffer = NULL, *send_buffer_start = NULL, *send_buffer_end = NULL;
    storage_db_chunk_info_t *chunk_info = NULL;
    size_t slice_length = 32;

    if (!module_redis_command_acquire_slice_and_write_blob_start(
            network_channel,
            32,
            entry_index->value->size,
            &send_buffer,
            &send_buffer_start,
            &send_buffer_end)) {
        return false;
    }

    network_send_buffer_release_slice(
            network_channel,
            send_buffer_start ? send_buffer_start - send_buffer : 0);

    // Build the chunks for the value
    for (storage_db_chunk_index_t chunk_index = 0; chunk_index < entry_index->value->count; chunk_index++) {
        char *buffer_to_send;
        size_t buffer_to_send_length;

        chunk_info = storage_db_chunk_sequence_get(entry_index->value, chunk_index);

        if (storage_db_entry_chunk_can_read_from_memory(
                db,
                chunk_info)) {
            buffer_to_send = storage_db_entry_chunk_read_fast_from_memory(
                    db,
                    chunk_info);
            buffer_to_send_length = chunk_info->chunk_length;
        } else {
            // TODO: once the on-disk database will be fully implemented this will not be necessary as the data will
            //       have to be in cache (memory) to be sent over the network
            if (send_buffer == NULL) {
                send_buffer = slab_allocator_mem_alloc(STORAGE_DB_CHUNK_MAX_SIZE);
            }

            res = storage_db_chunk_read(
                    db,
                    chunk_info,
                    send_buffer);

            if (!res) {
                LOG_E(
                        TAG,
                        "[REDIS][GET] Critical error, unable to read chunk <%u> long <%u> bytes",
                        chunk_index,
                        chunk_info->chunk_length);
                return false;
            }

            buffer_to_send = send_buffer;
            buffer_to_send_length = chunk_info->chunk_length;
        }

        // TODO: check if it's the last chunk and, if yes, if it would fit in the send buffer with the protocol
        //       bits that have to be sent later without doing an implicit flush
        if (network_send_direct(
                network_channel,
                buffer_to_send,
                buffer_to_send_length) != NETWORK_OP_RESULT_OK) {
            return false;
        }
    }

    send_buffer = send_buffer_start = network_send_buffer_acquire_slice(
            network_channel,
            slice_length);
    if (send_buffer_start == NULL) {
        LOG_E(TAG, "Unable to acquire send buffer slice!");
        return false;
    }

    send_buffer_start = protocol_redis_writer_write_argument_blob_end(
            send_buffer_start,
            slice_length);
    network_send_buffer_release_slice(
            network_channel,
            send_buffer_start ? send_buffer_start - send_buffer : 0);

    if (send_buffer_start == NULL) {
        LOG_E(TAG, "buffer length incorrectly calculated, not enough space!");
        return false;
    }

    return true;
}

bool module_redis_command_stream_entry(
        network_channel_t *network_channel,
        storage_db_t *db,
        storage_db_entry_index_t *entry_index) {
    // Check if the value is small enough to be contained in 1 single chunk and if it would fit in a memory single
    // memory allocation leaving enough space for the protocol begin and end signatures themselves.
    // The 32 bytes extra are required for the protocol data
    if (entry_index->value->count == 1 && entry_index->value->size < SLAB_OBJECT_SIZE_MAX - 32) {
        return module_redis_command_stream_entry_with_one_chunk(
                network_channel,
                db,
                entry_index);
    } else {
        return module_redis_command_stream_entry_with_multiple_chunks(
                network_channel,
                db,
                entry_index);
    }
}

#if DEBUG == 1
void module_redis_command_dump_argument(
        storage_db_t *db,
        uint32_t argument_index,
        module_redis_command_argument_t *argument,
        uintptr_t argument_context_base_addr,
        int depth) {
    int fake_count_1 = 1;
    bool argument_is_list = false;
    bool has_token = false;
    char depth_prefix[128] = { 0 };
    int *count;
    uintptr_t list;
    size_t list_item_size;

    char *argument_type_map[] = {
            "UNSUPPORTED",
            "KEY",
            "SHORT_STRING",
            "LONG_STRING",
            "INTEGER",
            "DOUBLE",
            "UNIXTIME",
            "BOOL",
            "PATTERN",
            "BLOCK",
            "ONEOF",
    };

    if (depth > 0) {
        sprintf(depth_prefix, "%.*s", depth*4, "                                                                ");
    }

    fprintf(
            stdout,
            "%s[%d] %s <%s%s>: ",
            depth_prefix,
            argument_index,
            argument->name,
            argument_type_map[argument->type],
            argument->has_multiple_occurrences ? "[]" : "");

    if (argument->has_multiple_occurrences) {
        argument_is_list = true;
    }

    list = argument_context_base_addr + argument->argument_context_member_offset;

    if (argument->token != NULL) {
        has_token = *(bool*)list;
        list += field_has_token_extra_padding;
    }

    if (argument_is_list) {
        count = (int *)(list + sizeof(void *));

        fprintf(stdout, "(%d items)\n", *count);

        if (*count == 0) {
            return;
        }

        // Get the pointer to the list
        void **list_ptr = (void*)list;

        // Because count > 0, the pointer to the list can't be null
        assert(*list_ptr != NULL);

        // Cast back the list_ptr to uintptr_t to assign it back to list
        list = (uintptr_t)*list_ptr;
    } else {
        count = &fake_count_1;
    }

    list_item_size = argument->argument_context_member_size;

    // If it's not a list, list[0] will be the base address, the loop will not move forward as the count is artificially
    // set to 1 via the fake_count_1 variable
    for (int index = 0; index < *count; index++) {
        storage_db_chunk_sequence_t *chunk_sequence;
        uintptr_t base_addr = (uintptr_t)(list + (list_item_size * index));

        if (argument_is_list) {
            fprintf(stdout,"%s    %d: ", depth_prefix, index);
        }

        switch (argument->type) {
            case MODULE_REDIS_COMMAND_ARGUMENT_TYPE_KEY:
                fprintf(
                        stdout, "%*s (%lu)\n",
                        (int)*(size_t*)(base_addr + offsetof(module_redis_key_t, length)),
                        *(char**)(base_addr + offsetof(module_redis_key_t, key)),
                        *(size_t*)(base_addr + offsetof(module_redis_key_t, length)));
                break;

            case MODULE_REDIS_COMMAND_ARGUMENT_TYPE_SHORT_STRING:
                fprintf(
                        stdout, "%*s (%lu)\n",
                        (int)*(size_t*)(base_addr + offsetof(module_redis_short_string_t, length)),
                        *(char**)(base_addr + offsetof(module_redis_short_string_t, short_string)),
                        *(size_t*)(base_addr + offsetof(module_redis_short_string_t, length)));
                break;

            case MODULE_REDIS_COMMAND_ARGUMENT_TYPE_LONG_STRING:
                chunk_sequence = *(storage_db_chunk_sequence_t**)(base_addr);

                if (chunk_sequence == NULL) {
                    fprintf(stdout, "NOT SET\n");
                } else {
                    bool is_short_value = chunk_sequence->size <= 64;

                    if (is_short_value) {
                        char buffer[64] = {0};
                        storage_db_chunk_read(
                                db,
                                storage_db_chunk_sequence_get(chunk_sequence, 0),
                                buffer);

                        fprintf(stdout, "%*s\n", (int) chunk_sequence->size, buffer);
                    } else {
                        fprintf(stdout, "<TOO LONG - %lu bytes>\n", chunk_sequence->size);
                    }
                }
                break;

            case MODULE_REDIS_COMMAND_ARGUMENT_TYPE_INTEGER:
                fprintf(stdout, "%ld\n", *(int64_t*)(base_addr));
                break;

            case MODULE_REDIS_COMMAND_ARGUMENT_TYPE_DOUBLE:
                fprintf(stdout, "%lf\n", *(double*)(base_addr));
                break;

            case MODULE_REDIS_COMMAND_ARGUMENT_TYPE_UNIXTIME:
                fprintf(stdout, "%ld\n", *(int64_t*)(base_addr));
                break;

            case MODULE_REDIS_COMMAND_ARGUMENT_TYPE_BOOL:
                fprintf(stdout, "%s\n", *(bool*)(base_addr) ? "true" : "false");
                break;

            case MODULE_REDIS_COMMAND_ARGUMENT_TYPE_PATTERN:
                fprintf(
                        stdout, "%*s (%lu)\n",
                        (int)*(size_t*)(base_addr + offsetof(module_redis_pattern_t, length)),
                        *(char**)(base_addr + offsetof(module_redis_pattern_t, pattern)),
                        *(size_t*)(base_addr + offsetof(module_redis_pattern_t, length)));
                break;

            case MODULE_REDIS_COMMAND_ARGUMENT_TYPE_BLOCK:
            case MODULE_REDIS_COMMAND_ARGUMENT_TYPE_ONEOF:
                fprintf(stdout, "\n");
                module_redis_command_dump_arguments(
                        db,
                        argument->sub_arguments,
                        argument->sub_arguments_count,
                        base_addr,
                        depth + 1);
                break;

            case MODULE_REDIS_COMMAND_ARGUMENT_TYPE_UNSUPPORTED:
                fprintf(stdout, "UNSUPPORTED!\n");
                break;
        }
    }

    if (argument->token != NULL) {
        fprintf(
                stdout,
                "%s    token <%s> is %s\n",
                depth_prefix,
                argument->token,
                has_token ? "true" : "false");
    }
}

void module_redis_command_dump_arguments(
        storage_db_t *db,
        module_redis_command_argument_t arguments[],
        int arguments_count,
        uintptr_t argument_context_base_addr,
        int depth) {

    for(int argument_index = 0; argument_index < arguments_count; argument_index++) {
        module_redis_command_dump_argument(
                db,
                argument_index,
                &arguments[argument_index],
                argument_context_base_addr,
                depth);
    }
}
#endif
